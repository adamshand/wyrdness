<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RNG Visual Feedback</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
    }

    #overlay {
      position: fixed;
      left: 16px;
      top: 16px;
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: rgba(255, 255, 255, 0.9);
      background: rgba(0, 0, 0, 0.35);
      padding: 10px 12px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      max-width: 360px;
    }

    #controls {
      margin-top: 8px;
      display: grid;
      gap: 6px;
    }

    label {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    input[type="range"] {
      width: 180px;
    }

    .muted {
      color: rgba(255, 255, 255, 0.65);
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div id="overlay">
    <div><b>RNG deviation visual</b></div>
    <div id="stats" class="muted"></div>
    <div id="controls">
      <label>Window bits <span><input id="win" type="range" min="500" max="20000" step="500"
            value="5000"></span></label>
      <label>Bits/sec <span><input id="bps" type="range" min="200" max="5000" step="100" value="1000"></span></label>
      <label>Smoothing <span><input id="alpha" type="range" min="0.01" max="0.3" step="0.01"
            value="0.08"></span></label>
      <button id="reset">Reset</button>
    </div>
    <div class="muted" style="margin-top:8px;">
      Typical randomness: |z| is usually &lt; ~2. Large |z| spikes will happen occasionally.
    </div>
  </div>

  <script>
    const statsEl = document.getElementById('stats');
    const winEl = document.getElementById('win');
    const bpsEl = document.getElementById('bps');
    const alphaEl = document.getElementById('alpha');
    const resetBtn = document.getElementById('reset');

    // Rolling bit window stored as bytes of 0/1 for simplicity.
    let windowBits = parseInt(winEl.value, 10);
    let bitsPerSec = parseInt(bpsEl.value, 10);
    let alpha = parseFloat(alphaEl.value);

    let bits = new Uint8Array(windowBits);
    let idx = 0;
    let ones = 0;
    let zSmooth = 0;

    function reseed() {
      bits = new Uint8Array(windowBits);
      idx = 0;
      ones = 0;
      zSmooth = 0;
    }

    function randBits(count) {
      // Generate count bits using crypto.getRandomValues
      const byteCount = Math.ceil(count / 8);
      const buf = new Uint8Array(byteCount);
      crypto.getRandomValues(buf);
      const out = new Uint8Array(count);
      for (let i = 0; i < count; i++) {
        const b = buf[i >> 3];
        out[i] = (b >> (i & 7)) & 1;
      }
      return out;
    }

    function step(dtMs) {
      // Target bits for this frame based on bitsPerSec
      const target = Math.max(1, Math.floor(bitsPerSec * (dtMs / 1000)));
      const newBits = randBits(target);

      for (let i = 0; i < newBits.length; i++) {
        const old = bits[idx];
        const neu = newBits[i];

        if (old === 1) ones--;
        if (neu === 1) ones++;

        bits[idx] = neu;
        idx = (idx + 1) % windowBits;
      }

      const N = windowBits;
      const E = N / 2;
      const sd = Math.sqrt(N / 4);
      const z = (ones - E) / sd;
      zSmooth = alpha * z + (1 - alpha) * zSmooth;

      render(z, zSmooth, ones, N);
    }

    function render(z, zS, ones, N) {
      // Map zSmooth to color:
      // hue: negative -> warm (30°), positive -> cool (200°)
      const hueNeg = 30, huePos = 200;
      const hue = zS >= 0 ? huePos : hueNeg;

      // brightness from |zSmooth| with gentle curve, clamp ~0..1
      const mag = Math.min(1, Math.abs(zS) / 4);     // |z|=4 => max
      const bright = 0.08 + 0.75 * Math.pow(mag, 0.8);
      const sat = 70; // fixed saturation for legibility

      document.body.style.background = `hsl(${hue} ${sat}% ${bright * 50}%)`;

      statsEl.textContent =
        `N=${N.toLocaleString()} bits • ones=${ones.toLocaleString()} • z=${z.toFixed(2)} • z(smooth)=${zS.toFixed(2)}`;
    }

    // Animation loop with dt
    let last = performance.now();
    function loop(now) {
      const dt = Math.min(200, now - last); // cap dt to avoid huge jumps when tab is backgrounded
      last = now;
      step(dt);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Controls
    winEl.addEventListener('input', () => {
      windowBits = parseInt(winEl.value, 10);
      reseed();
    });
    bpsEl.addEventListener('input', () => {
      bitsPerSec = parseInt(bpsEl.value, 10);
    });
    alphaEl.addEventListener('input', () => {
      alpha = parseFloat(alphaEl.value);
    });
    resetBtn.addEventListener('click', reseed);
  </script>
</body>

</html>